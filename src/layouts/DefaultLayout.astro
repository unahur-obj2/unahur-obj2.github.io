---
import '@astrojs/tailwind/base.css'
import '../assets/scss/globals.scss'
import SiteMeta from '@components/SiteMeta.astro'
import Header from '@components/Header.astro'

const {
	title = 'Astro',
	url,
	image = '/social-preview-image.png',
	author = 'Mark Teekman',
} = Astro.props
---

<html
	lang="en"
	dir="ltr">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0"
		/>
		<meta
			http-equiv="X-UA-Compatible"
			content="ie=edge"
		/>

		<!-- favicon -->
		<link
			rel="icon"
			type="image/svg+xml"
			href={'/LOGO.png'}
		/>

		<SiteMeta
			title={title}
			image={image}
			author={author}
		/>
	</head>
	<body>
		<Header />
		<main
			id="main-content"
			transition:animate="none">
			<slot />
		</main>
		<!-- <Footer /> -->

		<style lang="scss" is:global>
			// theme settings
			:root {
				--radius-small: 3px;
				--radius-large: 6px;
				--gap-default: 2rem;
				--font-measure: 70ch;
				--font-family-default: 'Open Sans', sans-serif;
				--font-family-special: 'Open Sans', sans-serif;
				// light theme
				--font-color: var(--neutral-900);
				--action-color: var(--primary-400);
				--action-color-state: var(--primary-500);
				--background: var(--neutral-500);
				--primary-background: var(--primary-100);
				--neutral-background: var(--neutral-200);
			}

			// dark color scheme overrides
			.darkmode {
				--font-color: var(--neutral-100);
				--action-color: var(--secondary-100);
				--action-color-state: var(--secondary-500);
				--background: var(--dark-100);
				--primary-background: var(--primary-500);
				--neutral-background: var(--neutral-900);
			}

			// sticky footer on low content pages
			html,
			body {
				height: 100%;
				overflow-x: hidden;
				scroll-behavior: smooth;
			}

			body {
				display: flex;
				flex-direction: column;
				color: var(--font-color);
				background-color: var(--background);

				main {
					flex: 1 0 auto;
				}

				footer {
					flex-shrink: 0;
				}
			}

			pre {
				padding: 1rem;
				border-radius: 0.35rem;
				border: 2px solid var(--action-color);
			}

			body .pagination a {
				&:hover,
				&:focus-visible {
					background-color: var(--action-color-state);

					svg path {
						stroke: white;
					}
				}
			}
		</style>

		<!-- Scripts de animaciones de entrada -->
		<script>
			// Sistema de animaciones de entrada para elementos de la página
			class EntranceAnimations {
				constructor() {
					this.initialized = false
					this.observerOptions = {
						threshold: 0.1,
						rootMargin: '0px 0px -50px 0px',
					}
				}

				// Inicializar animaciones cuando se carga la página
				init() {
					if (this.initialized) return

					// Marcar elementos para animación inicial
					this.setupInitialAnimations()

					// Configurar observer para animaciones en scroll (opcional)
					this.setupScrollAnimations()

					this.initialized = true
				}

				// Configurar animaciones que se ejecutan inmediatamente al cargar
				setupInitialAnimations() {
					// Animar elementos del hero
					this.animateHeroElements()

					// Animar elementos principales de la página
					this.animateMainContent()

					// Animar cards y elementos interactivos
					this.animateCards()
				}

				// Animar elementos del hero section
				animateHeroElements() {
					const heroSection = document.querySelector(
						'section[class*="hero"], section[class*="gradient"]'
					)
					if (!heroSection) return

					// Icono del hero
					const heroIcon = heroSection.querySelector('svg, img, .icon')
					if (heroIcon && !heroIcon.closest('.animate-pulse')) {
						heroIcon.classList.add('animate-on-load', 'hero-icon')
						requestAnimationFrame(() => {
							heroIcon.classList.remove('animate-on-load')
						})
					}

					// Título principal
					const heroTitle = heroSection.querySelector('h1')
					if (heroTitle) {
						heroTitle.classList.add('animate-on-load', 'hero-title')
						requestAnimationFrame(() => {
							heroTitle.classList.remove('animate-on-load')
						})
					}

					// Subtítulo
					const heroSubtitle = heroSection.querySelector('p')
					if (heroSubtitle) {
						heroSubtitle.classList.add('animate-on-load', 'hero-subtitle')
						requestAnimationFrame(() => {
							heroSubtitle.classList.remove('animate-on-load')
						})
					}

					// Botones de acción
					const heroButtons = heroSection.querySelector(
						'div[class*="flex"], .hero-buttons'
					)
					if (heroButtons && heroButtons.querySelector('a')) {
						heroButtons.classList.add('animate-on-load', 'hero-buttons')
						requestAnimationFrame(() => {
							heroButtons.classList.remove('animate-on-load')
						})
					}
				}

				// Animar contenido principal
				animateMainContent() {
					const sections = document.querySelectorAll(
						'section:not([class*="hero"]):not([class*="gradient"])'
					)

					sections.forEach((section, index) => {
						if (index === 0) {
							// Primera sección después del hero
							section.classList.add(
								'animate-on-load',
								'animate-entrance',
								'fade-in-up'
							)
							requestAnimationFrame(() => {
								section.classList.remove('animate-on-load')
							})
						}
					})

					// Animar títulos principales
					const mainTitles = document.querySelectorAll('h2, h3')
					mainTitles.forEach((title, index) => {
						if (index < 3) {
							// Solo los primeros 3 títulos
							title.classList.add(
								'animate-on-load',
								'animate-entrance',
								'fade-in-down',
								`stagger-${index + 1}`
							)
							requestAnimationFrame(() => {
								title.classList.remove('animate-on-load')
							})
						}
					})

					// Animar elementos con data-animate
					const animateElements = document.querySelectorAll('[data-animate]')
					animateElements.forEach((element, index) => {
						const animationType = element.dataset.animate || 'fade-in-up'
						const delay = Math.min(index * 0.1, 0.8)

						element.classList.add(
							'animate-on-load',
							'animate-entrance',
							animationType
						)
						element.style.animationDelay = `${delay}s`

						requestAnimationFrame(() => {
							element.classList.remove('animate-on-load')
						})
					})
				}

				// Animar cards y elementos tipo tarjeta
				animateCards() {
					const cards = document.querySelectorAll(
						'[class*="card"], [class*="rounded"], .bg-white, .bg-gray-50, [class*="shadow"]'
					)

					cards.forEach((card, index) => {
						// Solo animar las primeras 6 cards visibles
						if (index < 6 && this.isInViewport(card)) {
							const delay = Math.min(index, 5)
							card.classList.add(
								'animate-on-load',
								'card-entrance',
								`stagger-${delay + 1}`
							)

							requestAnimationFrame(() => {
								card.classList.remove('animate-on-load')
							})
						}
					})
				}

				// Configurar animaciones en scroll (para elementos que aparecen después)
				setupScrollAnimations() {
					if (!window.IntersectionObserver) return

					const observer = new IntersectionObserver((entries) => {
						entries.forEach((entry) => {
							if (
								entry.isIntersecting &&
								!entry.target.classList.contains('animated')
							) {
								this.animateElement(entry.target)
								entry.target.classList.add('animated')
							}
						})
					}, this.observerOptions)

					// Observar elementos que aparecen más tarde en la página
					const laterElements = document.querySelectorAll(
						'.animate-on-scroll, [data-animate]:not(.animate-on-load)'
					)
					laterElements.forEach((el) => observer.observe(el))
				}

				// Animar un elemento específico
				animateElement(element) {
					const animationType = element.dataset.animate || 'fade-in-up'
					element.classList.add('animate-entrance', animationType)
				}

				// Verificar si un elemento está en el viewport
				isInViewport(element) {
					const rect = element.getBoundingClientRect()
					return (
						rect.top >= 0 &&
						rect.left >= 0 &&
						rect.bottom <=
							(window.innerHeight || document.documentElement.clientHeight) &&
						rect.right <=
							(window.innerWidth || document.documentElement.clientWidth)
					)
				}

				// Limpiar y reinicializar (útil para navegación SPA)
				reset() {
					this.initialized = false

					// Remover clases de animación existentes
					const animatedElements = document.querySelectorAll(
						'.animate-entrance, .animated, .animate-on-load'
					)
					animatedElements.forEach((el) => {
						el.classList.remove(
							'animate-entrance',
							'animated',
							'animate-on-load',
							'fade-in-up',
							'fade-in-down',
							'fade-in-left',
							'fade-in-right',
							'scale-in',
							'slide-in-up',
							'bounce-in',
							'rotate-in',
							'zoom-in',
							'hero-title',
							'hero-subtitle',
							'hero-buttons',
							'hero-icon',
							'card-entrance',
							'stagger-1',
							'stagger-2',
							'stagger-3',
							'stagger-4',
							'stagger-5',
							'stagger-6'
						)
						el.style.animationDelay = ''
					})
				}
			}

			// Crear instancia global
			const entranceAnimations = new EntranceAnimations()

			// Inicializar cuando se carga la página
			document.addEventListener('DOMContentLoaded', () => {
				entranceAnimations.init()
			})

			// Reinicializar en navegación SPA (Astro)
			document.addEventListener('astro:page-load', () => {
				entranceAnimations.reset()
				setTimeout(() => {
					entranceAnimations.init()
				}, 50)
			})

			// Exportar para uso global
			window.entranceAnimations = entranceAnimations
		</script>
	</body>
</html>
